#!/usr/bin/env python3
import sys
sys.path.insert(0, '/mnt/project')

from api import TaskResult, unpack_args
import math
import hashlib
import struct

## SOME AI GENERATED TESTINGS TO VERIFY WORKABILITY 
# ============================================================
# HANDLERS
# 0x1100 - matrix_multiply
# 0x1101 - prime_factorize
# 0x1102 - monte_carlo_pi
# 0x1103 - hash_chunk
# 0x1104 - token_frequency
# 0x1105 - collatz_length
# 0x1106 - sort_generate
# 0x1107 - checksum_block
# ============================================================

def matrix_multiply_handler(slot, ctx):
    """Dense NxN matrix multiply (pure python). args[0]=N, args[1]=seed."""
    n = slot.args[0]
    seed = slot.args[1]

    # deterministic fill
    def fill(n, s):
        m = []
        v = s
        for i in range(n):
            row = []
            for j in range(n):
                v = (v * 6364136223846793005 + 1) & 0xFFFFFFFF
                row.append((v >> 16) & 0xFF)
            m.append(row)
        return m

    a = fill(n, seed)
    b = fill(n, seed + 1)

    c = [[0]*n for _ in range(n)]
    for i in range(n):
        ai = a[i]
        for k in range(n):
            aik = ai[k]
            bk = b[k]
            ci = c[i]
            for j in range(n):
                ci[j] += aik * bk[j]

    trace = sum(c[i][i] for i in range(n))

    if ctx.log_func:
        ctx.log_func(f"matmul {n}x{n} seed={seed} trace={trace & 0xFFFFFFFF}")

    return TaskResult(success=True, value=trace)


def prime_factorize_handler(slot, ctx):
    """Factorize a large-ish number. args[0]=base, args[1]=offset."""
    base = slot.args[0]
    offset = slot.args[1]
    n = abs(base * 1000003 + offset) | 1  # ensure odd and large-ish

    factors = []
    d = 2
    tmp = n
    while d * d <= tmp:
        while tmp % d == 0:
            factors.append(d)
            tmp //= d
        d += 1
    if tmp > 1:
        factors.append(tmp)

    if ctx.log_func:
        ctx.log_func(f"factor n={n} -> {len(factors)} primes")

    return TaskResult(success=True, value={'n': n, 'factors': factors})


def monte_carlo_pi_handler(slot, ctx):
    """Estimate pi via random sampling. args[0]=num_samples, args[1]=seed."""
    samples = slot.args[0]
    seed = slot.args[1]

    inside = 0
    # LCG state
    s = seed & 0xFFFFFFFF
    for _ in range(samples):
        s = (s * 1103515245 + 12345) & 0x7FFFFFFF
        x = s / 0x7FFFFFFF
        s = (s * 1103515245 + 12345) & 0x7FFFFFFF
        y = s / 0x7FFFFFFF
        if x*x + y*y <= 1.0:
            inside += 1

    pi_est = 4.0 * inside / samples

    if ctx.log_func:
        ctx.log_func(f"pi~{pi_est:.6f} samples={samples}")

    return TaskResult(success=True, value=pi_est)


def hash_chunk_handler(slot, ctx):
    """SHA-256 over a generated byte block. args[0]=block_kb, args[1]=rounds."""
    block_kb = max(slot.args[0], 1)
    rounds = max(slot.args[1], 1)

    # generate deterministic block
    block = bytes(range(256)) * (block_kb * 4)  # ~1KB per 4 repeats

    digest = block
    for _ in range(rounds):
        digest = hashlib.sha256(digest).digest()

    hex_short = digest[:8].hex()

    if ctx.log_func:
        ctx.log_func(f"sha256 {block_kb}KB x{rounds} -> {hex_short}")

    return TaskResult(success=True, value=hex_short)


def token_frequency_handler(slot, ctx):
    """Split c_args text on whitespace, count token frequencies."""
    raw = slot.c_args
    text = raw.split(b'\x00')[0].decode('utf-8', errors='replace')

    tokens = text.lower().split()
    freq = {}
    for t in tokens:
        freq[t] = freq.get(t, 0) + 1

    # sort descending
    top = sorted(freq.items(), key=lambda kv: kv[1], reverse=True)[:5]

    if ctx.log_func:
        preview = ' '.join(f"{w}:{c}" for w, c in top[:3])
        ctx.log_func(f"tokens={len(tokens)} top: {preview}")

    return TaskResult(success=True, value={'total': len(tokens), 'top': top})


def collatz_length_handler(slot, ctx):
    """Compute Collatz sequence length. args[0]=start, args[1]=unused."""
    start = max(slot.args[0], 1)

    n = start
    steps = 0
    peak = n
    while n != 1:
        if n % 2 == 0:
            n //= 2
        else:
            n = 3 * n + 1
        if n > peak:
            peak = n
        steps += 1

    if ctx.log_func:
        ctx.log_func(f"collatz({start}) steps={steps} peak={peak}")

    return TaskResult(success=True, value={'start': start, 'steps': steps, 'peak': peak})


def sort_generate_handler(slot, ctx):
    """Generate and sort an array. args[0]=length, args[1]=seed."""
    length = slot.args[0]
    seed = slot.args[1]

    # LCG fill
    s = seed & 0xFFFFFFFF
    arr = [0] * length
    for i in range(length):
        s = (s * 6364136223846793005 + 1) & 0xFFFFFFFF
        arr[i] = s

    arr.sort()

    median = arr[length // 2] if length > 0 else 0

    if ctx.log_func:
        ctx.log_func(f"sorted {length} elems median={median & 0xFFFF}")

    return TaskResult(success=True, value={'length': length, 'median': median})


def checksum_block_handler(slot, ctx):
    """CRC32-style rolling checksum. args[0]=block_size, args[1]=iterations."""
    block_size = max(slot.args[0], 64)
    iterations = max(slot.args[1], 1)

    # deterministic block
    block = bytearray(block_size)
    for i in range(block_size):
        block[i] = (i * 251 + 17) & 0xFF

    crc = 0xFFFFFFFF
    for _ in range(iterations):
        for b in block:
            crc ^= b
            for _ in range(8):
                if crc & 1:
                    crc = (crc >> 1) ^ 0xEDB88320
                else:
                    crc >>= 1

    crc ^= 0xFFFFFFFF
    hex_crc = f"{crc:08x}"

    if ctx.log_func:
        ctx.log_func(f"crc32 {block_size}B x{iterations} -> 0x{hex_crc}")

    return TaskResult(success=True, value=hex_crc)


# ============================================================
# HANDLER REGISTRY
# ============================================================
HANDLERS = {
    0x1100: matrix_multiply_handler,
    0x1101: prime_factorize_handler,
    0x1102: monte_carlo_pi_handler,
    0x1103: hash_chunk_handler,
    0x1104: token_frequency_handler,
    0x1105: collatz_length_handler,
    0x1106: sort_generate_handler,
    0x1107: checksum_block_handler,
}


# ============================================================
# LOREM CHUNKS (for token_frequency tasks)
# ============================================================
_LOREM = [
    b"lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua\x00",
    b"ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat\x00",
    b"duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur\x00",
    b"excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est laborum\x00",
    b"curabitur pretium tincidunt lacus nulla gravida orci a odio nullam varius dolor tempus arcu fusce purus\x00",
    b"pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas vestibulum tortor quam\x00",
    b"maecenas ullamcorper dui et placerat feugiat eros pede varius nisi condimentum id luctus nec molestie sit\x00",
    b"integer euismod lacus luctus magna quisque cursus metus vitae pharetra auctor sem massa mattis sem at interdum\x00",
]


if __name__ == "__main__":
    from api import MpopApi

    app = MpopApi(
        workers=4,
        display=True,
        handler_module=__name__,
        debug_delay= 0.003
    )

    # 1. matrix multiply 32x32, 200 tasks with varying seeds
    for i in range(200):
        app.enqueue(fn_id=0x1100, args=(32, i), tsk_id=i)

    # 2. prime factorization, 150 tasks
    for i in range(150):
        app.enqueue(fn_id=0x1101, args=(i + 7, i * 3), tsk_id=i + 1000)

    # 3. monte carlo pi, 10k samples each, 120 tasks
    for i in range(120):
        app.enqueue(fn_id=0x1102, args=(10000, i), tsk_id=i + 2000)

    # 4. sha256 hashing, 4KB blocks x 50 rounds, 100 tasks
    for i in range(100):
        app.enqueue(fn_id=0x1103, args=(4, 50), tsk_id=i + 3000)

    # 5. token frequency on lorem ipsum, 80 tasks
    for i in range(80):
        chunk = _LOREM[i % len(_LOREM)]
        app.enqueue(fn_id=0x1104, c_args=chunk, tsk_id=i + 4000)

    # 6. collatz sequence, large starting values, 160 tasks
    for i in range(1644):
        start = 100000 + i * 777
        app.enqueue(fn_id=0x1105, args=(start, 0), tsk_id=i + 5000)

    # 7. sort 10k element arrays, 90 tasks
    for i in range(90):
        app.enqueue(fn_id=0x1106, args=(10000, i), tsk_id=i + 6000)

    # 8. crc32 checksums, 1KB blocks x 100 iterations, 100 tasks
    for i in range(100):
        app.enqueue(fn_id=0x1107, args=(1024, 100), tsk_id=i + 7000)

    app.run()